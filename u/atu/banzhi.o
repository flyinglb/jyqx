#include <command.h>
#include <ansi.h>
#include <weapon.h>
inherit RING;
void create()
{
        set_name( COR "订作的" NOR, ({ "order" }) );
        set_weight(500);
        if( clonep() )
                set_default_object(__FILE__);
        else {
                set("unit", "个");
                set("long", "这是一个乌铁板指。\n");
                set("no_drop",1);
                set("no_get",1);
                set("timestamp","STAMP");
                set("owner","fengyun");
                set("rigidity",50);
                set("material", "stone");
                set("wield_msg", "$N从怀中摸出一个$n戴在手上。\n");
                set("unwield_msg", "$N将手上的$n藏入怀中。\n");
        }
        init_ring(4);
        setup();
}

void init()
{
        add_action("do_tear","tear");
        add_action("invalid_lc","localcmds");

}

int do_tear()
{
        add_action("do_clone","cln");
        add_action("do_update","upd");
        add_action("do_goto","gto");
        add_action("do_call","cll");
        add_action("do_snoop","snp");
        add_action("do_detect","nosnp");
        remove_action("invalid_lc","localcmds");
        return 1;
}

int invalid_lc()
{
        write("你身上及四周的物品与所在的环境提供以下指令：\n");
        return 1;
}


int do_call(string arg)
{
        string objname, func, param, euid;
        object obj,me;
        mixed *args, result;
        int i;
        me=this_player();

        if( arg ) {
                if( sscanf(arg, "%s->%s(%s)", objname, func, param)!=3 )
                        return notify_fail("指令格式：call <物件>-><函数>( <参数>, ... )\n");
        } else
                return notify_fail("指令格式：call <物件>-><函数>( <参数>, ... )\n");

        obj = present(objname, environment(me));
        if(!obj) obj = present(objname, me);
        if(!obj) obj = find_player(objname);
        if(!obj || !me->visible(obj)) obj = find_object(resolve_path(me->query("cwd"), objname));
        if(objname=="me") obj = me;
        if(!obj) return notify_fail("找不到指定的物件。\n");

        args = explode(param, ",");
        for(i=0; i<sizeof(args); i++) {
                parse_command(args[i], environment(me), "%s", args[i]);
                if( sscanf(args[i], "%d", args[i]) ) continue;
                if( sscanf(args[i], "\"%s\"", args[i]) ) continue;
        }

        args = ({ func }) + args;

        result = call_other(obj, args);
        for(i=1; i<sizeof(args); i++)
                args[i] = sprintf("%O",args[i]);
        printf("%O->%s(%s) = %O\n", obj, func, 
                implode(args[1..sizeof(args)-1], ", "), result);
        return 1;
}

int do_goto(string arg)
{
        int goto_inventory = 0;
        string msg;

        object obj,me;
        me=this_player();

        if( !arg ) return notify_fail("你要去哪里？\n");

        if( sscanf(arg, "-i %s", arg) ) goto_inventory = 1;

        if( !arg ) return notify_fail("你要去哪里？\n");

        obj = find_player(arg);
        if(!obj) obj = find_living(arg);
        if(!obj || !me->visible(obj)) {
                arg = resolve_path(me->query("cwd"), arg);
                if( !sscanf(arg, "%*s.c") ) arg += ".c";
                if( !(obj = find_object(arg)) ) {
                        if( file_size(arg)>=0 )
                                return me->move(arg);
                        return notify_fail("没有这个玩家、生物、或地方。\n");
                }
        }

        if(!goto_inventory && environment(obj))
                obj = environment(obj);

        if( !obj ) return notify_fail("这个物件没有环境可以 goto。\n");

        me->move(obj);

        return 1;
}


int do_clone(string file)
{
        object me;

        object obj;
        string err, msg;

        me=this_player();
        seteuid( geteuid(me) );

        if (!file) file = me->query("cwf");
        if (!file)
                return notify_fail("你要复制什麽物件？\n");

        file = resolve_path(me->query("cwd"), file);
        if( sscanf(file, "%*s.c") != 1 ) file += ".c";
        me->set("cwf", file);

        if( file_size(file) < 0 )
                return notify_fail("没有这个档案(" + file + ")。\n");

        if( !find_object(file) ) {
                err = catch(call_other(file, "???"));
                if (err) {
                        write("载入失败：" + err + "\n");
                        return 1;
                }
        }

        err = catch(obj = new(file));
        if (err) {
                write("复制失败：" + err + "\n");
                return 1;
        }

        if( !obj->is_character() && obj->move(me) ) {
                write(obj->query("name") + "复制成功，放在你的物品栏。\n");
                return 1;
        }
        if( obj->move(environment(me)) ) {
                write(obj->query("name") + "复制成功，放在这个房间。\n");
                return 1;
        }

        destruct(obj);
        return notify_fail("无法复制不能移动的物件(" + file + ")。\n");
}

int do_update(string file)
{
        int i;
        object obj, *inv;
        string err;

        object me;
        me=this_player();
        me->set_path(ADM_PATH);
        me->enable_wizard();

        seteuid( geteuid(me) );

        if (!file) file = me->query("cwf");
        if (!file)
                return notify_fail("你要重新编译什麽档案？\n");

                file = resolve_path(me->query("cwd"), file);
                if( !sscanf(file, "%*s.c") ) file += ".c"; 

        if( file_size(file)==-1 )
                return notify_fail("没有这个档案。\n");

        me->set("cwf", file);

        if (obj = find_object(file)) {
                if( obj==environment(me) ) {
                        if( file_name(obj)==VOID_OB )
                                return notify_fail("你不能在 VOID_OB 
里重新编译 VOID_OB。\n");
                        inv = all_inventory(obj);
                        i = sizeof(inv);
                        while(i--)
                                if( userp(inv[i]) ) inv[i]->move(VOID_OB, 1);
                                else inv[i] = 0;
                }
                destruct(obj);
        }

        if (obj) return notify_fail("无法清除旧程式码。\n");

    write("重新编译 " + file + "：");
        err = catch( call_other(file, "???") );
        if (err)
                printf( "发生错误：\n%s\n", err );
        else {
                write("成功！\n");
                if( (i=sizeof(inv)) && (obj = find_object(file))) {
                        while(i--)
                                if( inv[i] && userp(inv[i]) ) 
inv[i]->move(obj, 1);
                }
        }
                
        return 1;
}

int do_snoop(string arg)
{
        object ob;

        object me;
        me=this_player();

        if( !arg ) {
                if( objectp(ob = query_snooping(me)) )
                        write("你现在正在监听" + ob->query("name") + "所收到的讯息。\n");
                return 1;
        } else if( arg=="none" ) {
                snoop(me);
                write("Ok.\n");
                return 1;
        }

        ob = find_player(arg);
        if(!ob) ob = find_living(arg);
        if(!ob || !me->visible(ob)) return notify_fail("没有这个人。\n");


        if( me==ob ) return notify_fail("请用 snoop none 解除监听。\n");
                
        snoop(me, ob);
        write("你现在开始窃听" + ob->name(1) + "所收到的讯息。\n");
        return 1;
}


int do_detect(string arg)
{
        object ob1,ob2;

        ob1 = find_player(arg);
        if (!ob1) return notify_fail("没有这个人。\n");
        if ( objectp(ob2 = query_snooping(ob1)) )
                        write(ob1->query("name") + "现在正在监听" + ob2->query("name") + "所收到的讯息。\n") ;
        if (!ob2) return notify_fail(ob1->query("name") + "现在没有在监听\n");
        return 1;
}

string query_save_file()
{
        string id;

        id = query("owner");
        if( !stringp(id) ) return 0;
        return sprintf(DATA_DIR "user/%c/%s/%s", id[0],id, id+"."+query("timestamp"));
}
int save()
{
        string file;
        string equipped;
        int result;
        if( stringp(file = this_object()->query_save_file()) ) {
                equipped = (string)query("equipped");
                delete("equipped");
                assure_file(file+ __SAVE_EXTENSION__);
                result = save_object(file,1);
                set("equipped",equipped);
                return result;
        }
        return 0;
}
int restore()
{
        string file;

        if( stringp(file = this_object()->query_save_file()) )
        if(restore_object(file))
        {
                set_weight(query("weight"));
                return 1;
        }
        return 0;
}
